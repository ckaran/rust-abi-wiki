<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust ABI Wiki</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro/intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro/what_is_an_ABI.html"><strong aria-hidden="true">1.1.</strong> What is an ABI</a></li><li class="chapter-item expanded "><a href="intro/history.html"><strong aria-hidden="true">1.2.</strong> A Short History</a></li><li class="chapter-item expanded "><a href="intro/ip_summary.html"><strong aria-hidden="true">1.3.</strong> Initial Proposal Summary</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro/initial_proposal.html"><strong aria-hidden="true">1.3.1.</strong> Initial Proposal</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="discussion/discussion.html"><strong aria-hidden="true">2.</strong> Summary of the Discussion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="discussion/repr_c.html"><strong aria-hidden="true">2.1.</strong> repr(C) as the Lowest Common Denominator</a></li><li class="chapter-item expanded "><a href="discussion/terms.html"><strong aria-hidden="true">2.2.</strong> A Clarification of Terms</a></li><li class="chapter-item expanded "><a href="discussion/generics.html"><strong aria-hidden="true">2.3.</strong> Generics</a></li><li class="chapter-item expanded "><a href="discussion/swift_abi.html"><strong aria-hidden="true">2.4.</strong> The Swift ABI?</a></li><li class="chapter-item expanded "><a href="discussion/plugin_architecture.html"><strong aria-hidden="true">2.5.</strong> A Plugin-Style Architecture</a></li><li class="chapter-item expanded "><a href="discussion/layout.html"><strong aria-hidden="true">2.6.</strong> Laying out Memory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="discussion/memory_ffi.html"><strong aria-hidden="true">2.6.1.</strong> Memory Management Across FFI</a></li></ol></li><li class="chapter-item expanded "><a href="discussion/calling.html"><strong aria-hidden="true">2.7.</strong> Calling Conventions</a></li><li class="chapter-item expanded "><a href="discussion/selection.html"><strong aria-hidden="true">2.8.</strong> ABI Selection</a></li><li class="chapter-item expanded "><a href="discussion/one_ring.html"><strong aria-hidden="true">2.9.</strong> OneRing and ABI Boundaries</a></li><li class="chapter-item expanded "><a href="discussion/niches.html"><strong aria-hidden="true">2.10.</strong> Niches</a></li><li class="chapter-item expanded "><a href="discussion/glue.html"><strong aria-hidden="true">2.11.</strong> API/FFI, or, Code as Glue</a></li><li class="chapter-item expanded "><a href="discussion/final_picture.html"><strong aria-hidden="true">2.12.</strong> A Final Picture</a></li></ol></li><li class="chapter-item expanded "><a href="rust_compiler/rust_compiler.html"><strong aria-hidden="true">3.</strong> Rust's Compiler Infrastructure</a></li><li class="chapter-item expanded "><a href="towards_rfc/towards_rfc.html"><strong aria-hidden="true">4.</strong> Towards an RFC</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="towards_rfc/mvs.html"><strong aria-hidden="true">4.1.</strong> A Minimum Viable Subset</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust ABI Wiki</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Welcome to the Rust ABI Wiki! This is a wiki about Rust's ABI and plans to stabilize it. This wiki is very much so a work-in-progress, and we're trying to flesh it out. If you think of anything, open an issue or pull request to discuss it further! Here is this Wiki's <a href="https://github.com/slightknack/rust-abi-wiki">Github Repository</a>.</p>
<h2><a class="header" href="#overview" id="overview">Overview</a></h2>
<p>This wiki is currently organized into three sections: The <em>Introduction</em>, which is what you're reading now; this outlines the reasoning behind, history of, and terms used throughout the rest of this Wiki.</p>
<p>The <em>Discussion</em> pages summarize various points of discussion and link out to other resources for consideration. After reading this, you should have a pretty solid idea of the challenges we face and goals we have.</p>
<p>The <em>Rust Compiler</em> section outlines how the rust compiler currently works in regards to the ABI. This section should highlight all relevant parts of the compiler, and discuss how the ideas proposed via the discussion may be implemented.</p>
<p>With the Rust compiler infrastructure in mind, the <em>Towards an RFC</em> topic intends to form a precise proposal and actionable plan as to what needs to be done next. It's important that we understand the scope of what's possible:</p>
<blockquote>
<p>You can focus exclusively on that aspect if you want, but in that case you still need to think very carefully to avoid over-stating what use cases your proposal will actually enable.</p>
<p>— <code>@hanna-kruppe</code>, IRLO</p>
</blockquote>
<blockquote>
<p>So, tossing around the term &quot;ABI&quot; hides a world of work. And you need to consider ABIs you're not working on to preclude conflicts with the ones you are.</p>
<p>— <code>@vomlehn</code>, IRLO</p>
</blockquote>
<p>Although this Wiki serves as a general purpose knowledge-base and proposal silo, any the implications of any final proposals must be fully understood.</p>
<h1><a class="header" href="#what-even-is-an-abi" id="what-even-is-an-abi">What Even Is An ABI?</a></h1>
<p>ABIs, FFIs, ABI APIs, what's the difference?
This document stands to serve as a FAQ as to what an ABI is, why they're important, and so on.</p>
<p>If you think of a question, add it. If you feel an answer is incomplete or lacking, raise an issue - or even better - a PR.</p>
<h2><a class="header" href="#so-what-is-an-abi-anyway" id="so-what-is-an-abi-anyway">So, what is an ABI anyway?</a></h2>
<p>An ABI, or Application Binary Interface, is the public-facing API of an executable that determines how other programs can call into it.</p>
<p>Wikipedia explains this much more succinctly:</p>
<blockquote>
<p>In computer software, an application binary interface (ABI) is an interface between two binary program modules; often, one of these modules is a library or operating system facility, and the other is a program that is being run by a user.</p>
<p>— Wikipedia</p>
</blockquote>
<p>ABIs describe two main facilities:</p>
<ul>
<li>How data is laid out in memory</li>
<li>How functions are called.</li>
</ul>
<p>The C ABI is the oldest ABI, dating back to C. The C ABI can be used from Rust through the use of <code>extern &quot;C&quot;</code>. The C ABI, however, is fairly lacking, as it only provides basic datatypes and is rather inflexible.</p>
<p>However, it's important to note that 'ABI' in of itself is a bit of an overloaded term:</p>
<blockquote>
<p>More concretely: there are broadly two clusters of meanings for &quot;stable ABI&quot;, the first referring to how language concepts are mapped machine code (e.g. data structure layout, calling conventions) and the latter to the ability to change (upgrade) a software component without rebuilding all the software that interacts with this component. The second is ultimately the responsibility of programmers (e.g. deleting a function from a library breaks both source compatibility and ABI compatibility), but since it's required for many of the benefits ascribed to &quot;stable ABI&quot; and requires compiler support too, anyone pondering this subject should either explicitly acknowledge that aspect (and everything that it enables) as out of scope, or think about what it entails -- which goes far beyond &quot;freezing&quot; data structure layouts, calling conventions, etc.</p>
<p>— <code>@hanna-kruppe</code>, IRLO</p>
</blockquote>
<h2><a class="header" href="#what-does-it-mean-for-an-abi-to-be-stable" id="what-does-it-mean-for-an-abi-to-be-stable">What does it mean for an ABI to be stable?</a></h2>
<p>A stable ABI means that a compiler will consistently produce the same ABI for an executable across versions.</p>
<p>Right now, this invariant is not present in the Rust Compiler, as the compiler may perform certain memory-layout optimizations (such as zero-sizing), different across versions.</p>
<h2><a class="header" href="#why-is-a-stable-abi-a-good-thing" id="why-is-a-stable-abi-a-good-thing">Why is a stable ABI a good thing?</a></h2>
<p>To quote from the initial proposal:</p>
<blockquote>
<p>There are many benefits a standardized ABI would bring to Rust. A stable ABI enables dynamic linking between Rust crates, which would allow for Rust programs to support dynamically loaded plugins (a feature common in C/C++). Dynamic linking would result in shorter compile-times and lower disk-space use for projects, as multiple projects could link to the same dylib. For example, imagine having multiple CLIs all link to the same core library crate.</p>
</blockquote>
<blockquote>
<p>TODO: more recent examples.</p>
</blockquote>
<h2><a class="header" href="#what-would-a-stable-modular-abi-look-like-for-rust" id="what-would-a-stable-modular-abi-look-like-for-rust">What would a stable modular ABI look like for Rust?</a></h2>
<ul>
<li><strong>Fully specified</strong> - There should be no ambiguous cases, either in how to map Rust to the ABI, or how the ABI maps back to Rust objects.</li>
<li><strong>Versioned</strong> - There should be a mechanism to determine which version of the ABI a chunk of code is using by querying the code itself.  The version should follow <a href="https://semver.org/">semver</a> conventions, and should be both machine and human parseable, so that linkers and loaders can decide if two pieces of code are compatible (from an ABI standpoint).  Under some circumstances, it may be possible for a linker or loader to generate code to bind chunks of code together that have different ABI versions.</li>
<li><strong>Designed for introspection</strong> - There are tools for different operating systems to analyze blobs of code to determine what they do.  For Linux, there are <a href="https://linux.die.net/man/1/nm">nm</a>, <a href="https://linux.die.net/man/1/objdump">objdump</a>, and a number of other utilities.  Unfortunately, the tools are limited by the knowledge encoded in the executable formats; in most cases you can't read the docs for a library by reading the library itself.  A useful addition would be the ability to store the documentation for a library in one of the segments of the library, with tools that are able to find and display that information.</li>
</ul>
<h2><a class="header" href="#additional-useful-traits" id="additional-useful-traits">Additional useful traits</a></h2>
<p>While the ABI we're developing is primarily for the Rust language, it need not be solely for the rust language.  Here are some additional traits that the ABI could have that might be useful.</p>
<ul>
<li><strong>Useful outside of rust</strong> - There are numerous languages with numerous ABI specifications.  In some cases, those ABI specifications have been adopted by other languages, even when the ABI is not the best fit for the other languages.</li>
</ul>
<h2><a class="header" href="#whats-the-difference-between-an-abi-and-an-apiffi" id="whats-the-difference-between-an-abi-and-an-apiffi">What's the difference between an ABI and an API/FFI?</a></h2>
<p>We can go on all day talking about how <em>nice</em> and ABI would be, but after you say (or rather write) the word a couple hundred times, it loses it's meaning and rather encapsulates a set of rather lofty ideals.</p>
<p>This shouldn't be the case.</p>
<p>An ABI is something quite simple on the surface level: the memory layout and calling conventions of an executable. It can also be used in a broader sense, but it's best to be specific.</p>
<p>The FFI is the user-code interface the language provides to interact with other executables, which may have a different ABI. The FFI forms the transition layer between different ABIs. Currently, in Rust the FFI is most likened unto <code>extern &quot;C&quot;</code> and <code>repr(C)</code>.</p>
<h1><a class="header" href="#history" id="history">History</a></h1>
<p>Before we get started, I think it's important we highlight the loose history of the proposal. This will make it easier for new people to get indoctrinated into the conversation we've had thus far.</p>
<p>For those unfamiliar with Application Binary Interfaces, please read <a href="intro/what_is_an_ABI.html">the FAQ</a>.</p>
<h2><a class="header" href="#pre-irlo-discussion" id="pre-irlo-discussion">Pre IRLO discussion</a></h2>
<p>So far, there have been three primary stages in the history of this proposal. The idea for a stable ABI arose in a discussion in the Rust User's forum about programming languages that pair well with Rust. Inevitably, the discussion of FFIs arose, which lead to an constructive debate about Rust's ABI, from which then arose the <a href="intro/initial_proposal.html">initial proposal</a>.</p>
<h2><a class="header" href="#irlo-disussion" id="irlo-disussion">IRLO disussion</a></h2>
<p>On May 14th 2020, the Initial Proposal was posted to IRLO, where it received quite a lot of attention. There was a lot of discussion surrounding the proposal; so much, in fact, that the discussion became very deep and general at the same time - everyone attacked the problem from a different angle, and, although, after a 3 month period, the conversation subsided and a general consensus was reached, the length and complexity of the intertwining narratives was a bit hard to follow, to say the least. Now that the idea and interest were there, what was needed next was a bazaar-style, collected and directed effort towards enumerating design decisions and painting a clearer picture of what needed to be done. Hence, the Wiki.</p>
<h2><a class="header" href="#rust-abi-wiki" id="rust-abi-wiki">Rust ABI Wiki</a></h2>
<p>On October 23rd, A new effort to summarize the discussion and develop a solid, technical RFC. This effort is divided into three parts: First, the discussion on IRLO needs to be summarized and woven together into a coherent narrative; second, using the outline of the discussion, the relevant parts of the current Rust Compiler Infrastructure need to be targeted and Understood; finally, a terms must be defined and a solid RFC must be created.</p>
<h2><a class="header" href="#the-path-ahead" id="the-path-ahead">The Path Ahead</a></h2>
<p>Once this RFC has been created, this wiki will have fulfilled its purpose, and we can move towards following the RFC to create an actionable implementation. This does not mean that no experimentation should occur in the interim - au contraire - rather, a solid actionable plan is needed before any extensive implementation can be developed.</p>
<h1><a class="header" href="#summary-of-the-initial-proposal" id="summary-of-the-initial-proposal">Summary of the Initial Proposal</a></h1>
<p>The title of the initial post was, quite succinctly, 'A Stable Modular ABI for Rust'. Let's go over each of these terms in a bit more detail to get a better picture of what we're dealing with.</p>
<h2><a class="header" href="#stable" id="stable">'Stable'</a></h2>
<p>Currently, Rust's ABI is only stable across same versions of the compiler. This means that binaries that are built with different versions can not be dynamically linked, as the compiler does not guarantee that executables built with different versions will share a common interface.</p>
<p>This proposal calls for the stability of such an ABI to be guaranteed, at the least allowing for the compiler to link to older dynamic libraries built with older versions of the same compiler.</p>
<h2><a class="header" href="#modular" id="modular">'Modular'</a></h2>
<p>A stable ABI is no good if it is not resilient to future change.</p>
<h2><a class="header" href="#abi" id="abi">'ABI'</a></h2>
<h2><a class="header" href="#for-rust" id="for-rust">'for Rust'</a></h2>
<h2><a class="header" href="#line-of-reasoning" id="line-of-reasoning">Line of Reasoning</a></h2>
<p>Here's the line of reasoning behind the proposal, quoted:</p>
<blockquote>
<ul>
<li>A stable ABI would be really nice for Rust</li>
<li>But it would also be difficult to do</li>
<li>We propose a modular ABI, where compiler-time macros can determine the layout of datastructures so that they are ABI-compliant.</li>
<li>We discuss caveats</li>
<li>We ask for feedback.</li>
</ul>
<p>— <code>@isaac</code>, IRLO</p>
</blockquote>
<h2><a class="header" href="#difference-between-the-initial-proposal-and-the-general-consensus-now" id="difference-between-the-initial-proposal-and-the-general-consensus-now">Difference Between the Initial Proposal and the General Consensus Now</a></h2>
<p>After the initial proposal, quite a lot has changed. The initial proposal was very focused on using compile-time macros to determine memory layout. Since this proposal, it's become apparent that more than just memory layout is at stake, and new features must be introduced for FFI creation, binary linking, calling convention, niche expression, etc.</p>
<blockquote>
<p>This is the very first initial proposal that led to the subsequent discussion on IRLO. This document is a bit outdated, and is largely here for archival purposes.</p>
</blockquote>
<h1><a class="header" href="#proposing-a-stable-modularizable-abi-interface-for-rust" id="proposing-a-stable-modularizable-abi-interface-for-rust">Proposing a stable modularizable ABI interface for Rust</a></h1>
<p>Based on the points from the discussion <a href="https://users.rust-lang.org/t/modular-abi-for-rust/42590">here</a>.</p>
<h2><a class="header" href="#introduction-1" id="introduction-1">Introduction</a></h2>
<p>Rust is a powerful systems programming with strong memory guarantees. Rust allows for concise expression at a high-level, while still producing fast low-level code. However, Rust does not guarantee the calling conventions and layout of structures in memory, which makes it difficult to write external applications that interface with Rust; Rust lacks a standardized ABI. Standardizing Rust's ABI has been brought up before, but has usually gone nowhere due to the difficulty of the task. In this post, we outline the benefits and stumbling-blocks of a stable ABI, as well as suggest a semi-novel technique as to how such an ABI could be implemented.</p>
<h2><a class="header" href="#benefits" id="benefits">Benefits</a></h2>
<p>There are many benefits a standardized ABI would bring to Rust. A stable ABI enables dynamic linking between Rust crates, which would allow for Rust programs to support dynamically loaded plugins (a feature common in C/C++). Dynamic linking would result in shorter compile-times and lower disk-space use for projects, as multiple projects could link to the same dylib. For example, imagine having multiple CLIs all link to the same core library crate.</p>
<p>Although this use case is already rather well covered by <a href="https://github.com/rodrimati1992/abi_stable_crates"><code>abi-stable-crates</code></a>, there are still many more benefits beyond linking crates dynamically. A stable ABI would allow Rust libraries to be loaded by other languages (such as Swift), and would allow Rust to interop with libraries defined in other programming languages. Non-Rust crates could be integrated with Rust toolchains; providing an ABI would also allow outside code to rely on Rust for performance-intensive tasks. Cross-language compatibility would increase the diversity of Rust's package ecosystem.</p>
<blockquote>
<p><strong><a href="https://internals.rust-lang.org/t/dynamically-linking-rust-crates-to-rust-crates/10369/8?u=zicklag">Quote</a>:</strong>  Imho one of the biggest mistakes C++ ever made was not stabilizing its abi; swift just stabilized theirs and is already reaping the benefits, swift system libraries, the swift runtime, swift UI libraries, all dynamically linked and backwards abi compatible.</p>
</blockquote>
<p>Stabilizing the Rust's ABI would allow for cross language interop and dynamic linking. &quot; <code>extern &quot;C&quot;</code>  as the lowest common denominator is too low for Rust&quot; (<strong><a href="https://internals.rust-lang.org/t/dynamically-linking-rust-crates-to-rust-crates/10369/35?u=zicklag">Quote</a></strong>).</p>
<p>Recently, the Fuschia OS Team at Google decided to ban Rust's for use in Fuschia microkernel, citing C as an alternative because of its stable ABI. Not providing a stable ABI ultimately hurts Rust when getting down to the metal. Given similar languages like C and Swift have a stable ABI, I see no reason why a stable ABI would not be implementable for Rust. As discussed <a href="https://internals.rust-lang.org/t/dynamically-linking-rust-crates-to-rust-crates/10369/38">here</a>, some ABIs/FFIs have already been written using proc macro and the like.</p>
<h2><a class="header" href="#potential-issues" id="potential-issues">Potential Issues</a></h2>
<p>However, a stable ABI is not all peaches and roses. Having to standardize the memory layout of data can limit the number of optimizations the compiler can perform.There has been a lot of work on <a href="http://www.catb.org/esr/structure-packing/">optimizing laying out fields in structs</a> in reliable and ABI-compliant ways. There are a large class of optimizations that can be done in compliance with an ABI; since an ABI solidifies the layout of data, more reliable bit-twiddling and the like can occur.</p>
<p>While discussing the matter, a point was brought up that the ABI could be modularized. A modularized ABI would be optional while compiling. This modular ABI could be published as a versioned crate. If the ABI ever needs a backward-compatibility breaking change, the change could be made within Semver. Alternatively, a new ABI-compliant compiler backend could be developed, or the current compiler backend could be extended to support an ABI feature flag that would toggle ABI compliant builds.</p>
<p>However:</p>
<blockquote>
<p><strong><a href="https://users.rust-lang.org/t/modular-abi-for-rust/42590/12?u=isaac">Quote</a>:</strong> Depending on the implementation, if we want to make ABI plugins, to avoid stabilizing the compiler's built-in ABI, we might run into another problem because we have to stabilize the plugin interface, which could be another can of worms.</p>
</blockquote>
<p>Standardizing the ABI would take a lot of work. A poorly designed ABI is worse than not having an ABI at all. And as we all know, the right solution is often the hardest one.</p>
<p>Another downside is that allowing ABI crates might not stabilize Rust's ABI, there'd just be ABI fragmentation. Although this is a genuine concern, a 'master' ABI crate with Rust's 'official' ABI could be developed. This would standardize Rust's ABI, while still allowing other crates with other ABI's to be written for interop with other ABIs, like Swift's. Additionally, because modular ABIs are opt-in, ABIs would be used only where explicitly necessary.</p>
<h2><a class="header" href="#implementation-proposal" id="implementation-proposal">Implementation Proposal</a></h2>
<p>So, what might this modularized ABI look like? Roughly speaking, an ABI would be defined by a series of macros in a crate which specify the layout and calling conventions of data structures according to that ABI. During compilation, while determining the layout of the data, the layout information provided by the ABI macros would be used. The end-goal would be for something like  <code>#[repr(RustABI)]</code>  or  <code>$ cargo build --release --abi rust-abi</code>  to be plausible.</p>
<p>Let's get into more detail. Right now, the closest analogue to a stable Rust ABI is the <code>abi_stable</code> crate. <code>abi_stable</code> uses <code>#[repr(C)]</code> to create ABI-compatible data structures. This is a step in the right direction, but every ABI-complaint type has to pass through <code>abi_stable</code>'s mechanisms. These data-structures are also more expressively limited. For example, every <code>abi_stable</code> ABI struct has to contain ABI compatible fields - and some Rust types, like <code>Result</code>, aren't compatible at all.</p>
<p>A modular ABI could solve this issue. An &quot;ABI&quot; Rust crate is a proc-macro-like crate that determines exactly how each byte of a data-structure should be laid out in memory. To do this, the &quot;ABI&quot; crate should provide a macro each standard Rust data-structure (<code>struct</code>, <code>enum</code>, <code>tuple</code>, etc.) When a data-structure is marked as ABI-compliant (either through a <code>#[repr(ABI)]</code> proc macro or compiler flag), the compiler calls out the &quot;ABI&quot; crate which recursively lays out said data-structure in an ABI-compliant manner.</p>
<p>There are a few issues that still need to be addressed. How do pointers and memory management work across FFI boundaries? We propose that when ABI-compliant data is transferred across an FFI boundary, it should be either copied or moved. Once some data has moved across an FFI boundary, the only way to reference that data is to use the copy, or have the program the data was transferred to transfer it back. This copy/move borrowing technique is merely a suggestion, as there is probably a better way to do it (<a href="https://internals.rust-lang.org/t/sketch-minimal-pimpl-style-stable-abi/10952">semi-related post</a>).</p>
<p>To determine the layout of data for Rust's own ABI, a minimum API would have to be found. Rust currently provides many niche optimizations and field ordering techniques to increase performance - a stable ABI might interrupt or prevent some of this. However, as mentioned in the Potential Issues section, there are ways to work around this. Different calling conventions could be supported through a proxy assemble stub or the like, but the <a href="https://internals.rust-lang.org/t/dynamically-linking-rust-crates-to-rust-crates/10369/38?u=zicklag">devil's always in the details</a>.</p>
<p>Multiple ABI crates would be able to be defined—for example, there could be an <code>abi_swift</code> crate for interop with Swift's ABI—Rust itself could have it's own ABI in an ABI crate titled <code>abi_rust</code> or the like.</p>
<blockquote>
<p><strong><a href="https://users.rust-lang.org/t/modular-abi-for-rust/42590/33?u=isaac">Quote</a>:</strong> The potential to have different ABIs (e.g., <code>abi_rust</code>, <code>abi_swift</code>) that are used concurrently in the same compilation would permit Rust programs to act as the &quot;glue&quot; between external components that use incompatible ABIs.</p>
</blockquote>
<h2><a class="header" href="#closing-thoughts" id="closing-thoughts">Closing Thoughts</a></h2>
<p>We hope that this outline of a very rough specification will provide a launching point for the ultimate development of a stable modularized ABI interface for Rust. Such an ABI would expand the number of applications that Rust could be used for. A stable ABI would standardize dynamic linking between Rust crates, minimize the amount of space-time used during compilation, allow for cross-compatibility between Rust and other programming languages, and increase the plausibility of Rust as a kernel-level language. Something like this takes hard work and good communication, so if you have any questions, comments, concerns, feedback, or other ideas, please don't hesitate to share.</p>
<h1><a class="header" href="#summary-of-the-discussion" id="summary-of-the-discussion">Summary of the Discussion</a></h1>
<h1><a class="header" href="#reprc-as-the-lowest-common-denominator" id="reprc-as-the-lowest-common-denominator"><code>repr(C)</code> as the Lowest Common Denominator</a></h1>
<h2><a class="header" href="#headers" id="headers">Headers</a></h2>
<blockquote>
<p>In the C world, there is a relatively simple relation between these two aspects: everything you put into (&quot;public&quot;) headers is part of the ABI, and if you want the ability to e.g. change the layout of a type without breaking ABI compatibility, then you need to make that struct an opaque type in the headers and e.g. expose getter/setter functions for fields whose existence you want to guarantee.</p>
<p>— <code>@hanna-kruppe</code>, IRLO</p>
</blockquote>
<h1><a class="header" href="#a-clarification-of-terms" id="a-clarification-of-terms">A Clarification of Terms</a></h1>
<h1><a class="header" href="#generics" id="generics">Generics</a></h1>
<h1><a class="header" href="#the-swift-abi" id="the-swift-abi">The Swift ABI?</a></h1>
<h1><a class="header" href="#a-plugin-style-architecture" id="a-plugin-style-architecture">A Plugin-Style Architecture</a></h1>
<h1><a class="header" href="#laying-out-memory" id="laying-out-memory">Laying out Memory</a></h1>
<blockquote>
<p>TODO: flesh out
Include this <a href="https://gankra.github.io/blah/rust-layouts-and-abis/">article</a></p>
</blockquote>
<h1><a class="header" href="#memory-management-across-ffi" id="memory-management-across-ffi">Memory Management Across FFI</a></h1>
<p>An issue with an FFI is that any memory transferred across boundaries is, in essence, being managed by two programs at once. This is a bit of an issue - Rust, as a language, provides strong memory guarantees - and the point of a clean FFI API is to make it as simple as possible to use; an <code>unsafe</code> block should not need to wrap every call to and from an external ABI.</p>
<p>With that in mind, what is the solution to this? How can data be transferred across programs without violating data lifetimes?</p>
<p>Once some data has been <em>moved</em> across a FFI boundary, the program that passed the data on no longer retains ownership of that data. This is similar to move semantics in closures, etc.</p>
<p>What about pointers?</p>
<blockquote>
<p>The only consistent answer to that is that the calling convention of the function pointer (extern &quot;Rust&quot;, extern &quot;C&quot;, extern &quot;Swift&quot;) is part of the function type, the same as layout (#[repr(Rust)], #[repr(C)], #[repr(Swift)]) is part of the struct type.</p>
<p>— @CAD97, IRLO</p>
</blockquote>
<blockquote>
<p>TODO: reread through discussion and expand on this point.</p>
</blockquote>
<h1><a class="header" href="#calling-conventions" id="calling-conventions">Calling Conventions</a></h1>
<h1><a class="header" href="#abi-selection" id="abi-selection">ABI Selection</a></h1>
<h1><a class="header" href="#onering-and-abi-boundaries" id="onering-and-abi-boundaries">OneRing and ABI Boundaries</a></h1>
<blockquote>
<p>It seems like developing language-independent ABI which significantly improves over C, without being Rust specific, is possible. Slices, tagged unions, utf8 strings, borrowed closures are features which immediately come to mind and have obvious-ish implementations.
— <code>@matklad</code>, IRLO</p>
</blockquote>
<h1><a class="header" href="#niches" id="niches">Niches</a></h1>
<h1><a class="header" href="#apiffi-or-code-as-glue" id="apiffi-or-code-as-glue">API/FFI, or, Code as Glue</a></h1>
<blockquote>
<p>It is important to have a robust API/FFI, making it easy to glue C and Rust together, and pass around safe data structures like counted buffers without writing a lot of repetitive unsafe glue code.
— <code>@josh</code>, IRLO</p>
</blockquote>
<h1><a class="header" href="#a-final-picture" id="a-final-picture">A Final Picture</a></h1>
<h1><a class="header" href="#rusts-compiler-infrastructure" id="rusts-compiler-infrastructure">Rust's Compiler Infrastructure</a></h1>
<p>Now that we've gotten a solid idea about what ABI is, and how it functions, let's talk about Rust. Specifically Rust's compiler. Rust's binaries <em>do</em> have an ABI - but what does that ABI look like? Where is it determined? What's preventing it from being stable?</p>
<p>These are some questions we hope to answer in the following chapters.</p>
<h1><a class="header" href="#towards-an-rfc" id="towards-an-rfc">Towards an RFC</a></h1>
<p>Now that we have a solid understanding of both ABI and how they relate to Rust's Compiler, I think it's time we consolidate what we've learned so far and outline the general topics for a (Pre-)RFC.</p>
<h1><a class="header" href="#a-minimum-viable-subset" id="a-minimum-viable-subset">A Minimum Viable Subset</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
